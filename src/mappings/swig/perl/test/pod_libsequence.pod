=begin hidden

  BEGIN{unshift(@INC, "../libsequence")};
  use biolib::libsequence;
  
=end hidden

=head1 General I/O

=head2 class Fasta

FASTA Sequence Stream


Fasta(): Generic Constructor

  my $fasta = new libsequence::Fasta();
  
Fasta(name, seq): Constructor for const std::string

  my $fasta = new libsequence::Fasta('dna', 'ATGC');
  
Fasta(fastaObj): Copy constrctor

  my $copy_fasta = new libsequence::Fasta($fasta);
  
GetName(): Return the sequence name
  
  my $name = $fasta->GetName();
  is($name, 'dna');
  
GetSeq(): Return the sequence itself

  my $seq = $fasta->GetSeq();
  is($seq, 'ATGC');

length(): Return the total length of the sequence

  my $len = $fasta->length();
  is($len, 4);
  
UngappedLength(): Return length of sequence, excluding the gap character '-'

  my $fasta1 = new libsequence::Fasta('dna', 'A-C-T');
  my $ungapped_len = $fasta1->UngappedLength();
  is($ungapped_len, 3);
  
IsGapped(): Returns 1 if the sequence contaings the gap character '-', 0 otherwise

  ok($fasta1->IsGapped());
  
substr(beg, len): Returns a substring of the current string, starting at index 'beg' with 'len' characters long.
if len is omitted, returns the substring from index 'beg' to the end of the string.
  
  my $sub_str = $fasta->substr(1, 2);
  is($sub_str, 'TG');
  my $sub_str = $fasta->substr(2);
  is($sub_str, 'GC');
  
c_str(): Returns the C-style string representing the sequence as a cont char *

  is($fasta->c_str(), 'ATGC');
  
to_std_str(): Allows (implict) cast to std::string

  is($fasta->to_std_str(), 'ATGC');
  
Complement():  Complement the Sequence

  $copy_fasta->Complement();
  is($copy_fasta->GetSeq(), 'TACG');
  
Revcom(): Reverse and complement the sequence

  $copy_fasta->Revcom();
  is($copy_fasta->GetSeq(), 'CGTA');

Operator ==: Returns 1 if the sequences contain the same data, 0 otherwise.

  ok(!($fasta == $fasta1));
  
Operator !=: Returns 0 if the sequences contain the same data, 1 otherwise.

  ok($fasta != $fasta1);
  
Operator []: Return the i-th element of the sequence.

  #is($fasta[1], 'T');
  is($fasta->__getitem__(1), 'T');
  
~Fasta(): Destructor

  $fasta->DESTROY();
  $copy_fasta->DESTROY();
  $fasta1->DESTROY();
 

=head2 class ClustalW_str

This class defines an input routine for alignments in ClustalW format, which is instantiated with the following types:
std::pair<std::string, std::string>

ClustalW_str(): Default constrctor

  my $clus_null = new libsequence::ClustalW_str();

ClustalW_str(strPairObj):strPairObj is an object instantiated from std::vector< std::pair<std::string, std::string> >

  my $pv = new libsequence::pVector(2);
  $pv->set(0, libsequence::strPair->new('s1', 'ATGGC'));
  $pv->set(1, libsequence::strPair->new('s2', 'CC-TT'));
  my $clus = new libsequence::ClustalW_str($pv);
  
size(): Returns data.size(),i.e. the length of vector

  is($clus->size(),2);
  
Data(): Returns the std::vector < std::pair<std::string, std::string > data

  my $clus_data = $clus->Data();
  is($clus_data->[0]->swig_second_get, 'ATGGC');
  is($clus_data->[1]->swig_second_get, 'CC-TT');
  
assign(): Assign data to object. Since the value type for these iterators evaluates to std::vector<T>::const_iterator, any vector<T> 
can be the data source

  $clus_null->assign($clus->begin_const(), $clus->end_const());
  is($clus_null->Data()->[0]->swig_second_get, 'ATGGC');

Clustal_str(Clustal_strObj): Copy constructor

  my $copy_clus = new libsequence::ClustalW_str($clus);
  
Gapped(): Retruns true if the vector contains a gap character ('-') , false otherwise.

  ok($clus->Gapped());
  
UnGappedLength():  """Returns the number of sites in the alignment for which all objects do not contain the gap character '-'. If the
data are not aligned, the value Sequence::SEQMAXUNSIGNED is returned as an error

  is($clus->UnGappedLength(), 4);
  
RemoveGaps(): Modifies the data vector to remove all positions that contain the gap character'-'.

  $clus->RemoveGaps();
  ok(!($clus->Gapped()));
  
IsAlignment():Returns Ture if all strings in CLustal Object are the same length.

  ok($clus->IsAlignment());
  
operator []: Returns the i-th object in the vector data

  is($clus->__getitem__(0)->swig_second_get, 'ATGC');
  is($clus->__getitem__(1)->swig_second_get, 'CCTT');
  
RemoveTerminalGaps(): Remove all gapped sites from the ends of the alignment, up until the first site on either side that is ungapped.

  my $pv1 = new libsequence::pVector(2);
  $pv1->set(0, libsequence::strPair->new('s1','-GTCA-T'));
  $pv1->set(1, libsequence::strPair->new('s2','TTAC-C-'));
  my $clus1 = new libsequence::ClustalW_str($pv1);
  $clus1->RemoveTerminalGaps();
  is($clus1->__getitem__(0)->swig_second_get, 'GTC');
  is($clus1->__getitem__(1)->swig_second_get, 'TAC');
  
Trim(sites): Returns a copy of the data vector, modified in the following way. The sites vector contains an even number of sites 
(whose values are sorted). If sites does not contain an even number of values Sequence::SeqException is thrown. If sites is 
empty, Sequence::SeqException is thrown. The values in sites represent a series of intervals that you wish to keep, and the 
return vector is consists only of those--i.e. all positions not present in the intervals defined in sites are lost.
For example, if you pass a vector<int> containing the values 0,10,21, and 30, then the data vector is modified so that positions 0 through 10 and 21 through 30 are all
that remains. One intended use of this function is to pull, for example, the coding region out of an aligned block.

Parameters:
sites 	vector<int> containing an even number of integers specifying the intervals of data to keep

  my $sites = new libsequence::intVector(2);
  $sites->set(0,0);
  $sites->set(1,2);
  is($clus->Trim($sites)->[0]->swig_second_get, 'ATG');
  is($clus->Trim($sites)->[1]->swig_second_get, 'CCT');
  
TrimComplement(sites):Returns a copy the data vector, modified in the following way. The sites vector contains an even number
of sites (whose values are sorted). If sites does not contain an even number of values. Sequence::SeqException is thrown. If 
sites is empty, Sequence::SeqException is thrown. The values in sites represent a series of intervals that you wish to keep, 
and the return vector consists only of sites not present in sites--i.e. all positions not present in the intervals defined in 
sites are kept. For example, if you pass a vector<int> containing the values 0,10,21, and 30, then the data vector is modified 
so that positions 11 through 20 and 31 through the end of the sequences are all that remains.
  
Parameters:
sites vector<int> containing an even number of integers specifying the intervals of data to throw away

  is($clus->TrimComplement($sites)->[0]->swig_second_get, 'C');
  is($clus->TrimComplement($sites)->[1]->swig_second_get, 'T');
  
~ClustalW(): Destructor

  $clus->DESTROY();
  

=head2 sub IsAlignment_strPair(data)

A vector of sequences/strings is only an alignment if all strings are the same length.

Paramerter: 
data 	vector<std::pair<std::string, std::string> > to check

  my $v = new libsequence::pVector(2);
  $v->set(0, libsequence::strPair->new('s1','GT-CAG'));
  $v->set(1, libsequence::strPair->new('s2','-C-NT-'));
  ok(libsequence::IsAlignment_strPair($v));

=head2 sub Gapped_strPair(data)

Returns:true if the vector contains a gap character ('-') , false otherwise.

  ok(libsequence::Gapped_strPair($v));
  
  
=head2 sub RemoveGaps_strPair(data)

Modifies the data vector to remove all positions that contain the gap character'-'.

  my $v1 = $v;
  libsequence::RemoveTerminalGaps_strPair($v1);
  is($v1->get(0)->swig_second_get, 'T-CA');
  is($v1->get(1)->swig_second_get, 'C-NT');
  
=head2 sub UnGappedLength_strPair(data)

Returns the number of sites in the alignment for which all objects do not contain the gap character '-'. If the data are not aligned,
the value Sequence::SEQMAXUNSIGNED is returned as an error

  is(libsequence::UnGappedLength_strPair($v), 3);
  
=head2 sub Trim_strPair(data, sites)

Returns a copy of the data vector, modified in the following way. The sites vector contains an even number of sites 
(whose values are sorted). If sites does not contain an even number of values Sequence::SeqException is thrown. If sites is 
empty, Sequence::SeqException is thrown. The values in sites represent a series of intervals that you wish to keep, and the 
return vector is consists only of those--i.e. all positions not present in the intervals defined in sites are lost.
For example, if you pass a vector<int> containing the values 0,10,21, and 30, then the data vector is modified so that positions 0 through 10 and 21 through 30 are all
that remains. One intended use of this function is to pull, for example, the coding region out of an aligned block.

Parameters:
sites 	vector<int> containing an even number of integers specifying the intervals of data to keep

  is(libsequence::Trim_strPair($v, $sites)->[0]->swig_second_get, 'T-C');
  is(libsequence::Trim_strPair($v, $sites)->[1]->swig_second_get, 'C-N');
  
=head2 sub TrimComplement_strPair(data,sites)

Returns a copy the data vector, modified in the following way. The sites vector contains an even number
of sites (whose values are sorted). If sites does not contain an even number of values. Sequence::SeqException is thrown. If 
sites is empty, Sequence::SeqException is thrown. The values in sites represent a series of intervals that you wish to keep, 
and the return vector consists only of sites not present in sites--i.e. all positions not present in the intervals defined in 
sites are kept. For example, if you pass a vector<int> containing the values 0,10,21, and 30, then the data vector is modified 
so that positions 11 through 20 and 31 through the end of the sequences are all that remains.
  
Parameters:
sites vector<int> containing an even number of integers specifying the intervals of data to throw away

  is(libsequence::TrimComplement_strPair($v, $sites)->[0]->swig_second_get, 'A');
  is(libsequence::TrimComplement_strPair($v, $sites)->[1]->swig_second_get, 'T');
  
=head2 sub RemoveFixedOutgroupInsertions_strPair(data, sites, ref)

Removes all positions from data that for which the outgroup contains an insertion relative to ingroup

Parameters:
data 	a vector of Seq objects
site 	index of the site at which to begin (set to 0 usually)
ref 	the index of the outgroup in data

  libsequence::RemoveFixedOutgroupInsertions_strPair($v,0,3);
  is($v->get(0)->swig_second_get, 'T-CA');
  is($v->get(1)->swig_second_get, 'C-NT');
  
=head2 sub validForPolyAnalysis_strPair(beg,end):

Returns:true if each element in the range [beg,end) only contains characters in the set {A,G,C,T,N,-}, false otherwise

>   my $beg = $v->begin();
>   my $end = $v->end();

=head2 sub EmptyVector_strPair(*seqarray)

Free all the memory in seqarray by deleting every objet, and resize() seqarray to 0

  my $pp = new libsequence::ppVector(2);
  my $p1 = $v->get(0);
  my $p2 = $v->get(1);
  $pp->set(0, libsequence::strPairPointer($p1));
  $pp->set(1, libsequence::strPairPointer($p2));
  #print $pp->get(0)->swig_second_get;
  #print $p1->swig_second_get;
  #libsequence::EmptyVector_strPair($pp);

#=for POD::Tested reset

=head2 sub IsAlignment_Fasta(data)

A vector of sequences/strings is only an alignment if all strings are the same length.

Paramerter: 
data 	vector<Sequence::Fasta> to check

  my $v = new libsequence::fastaVector(2);
  $v->set(0, libsequence::Fasta->new('s1','GT-CAG'));
  $v->set(1, libsequence::Fasta->new('s2','-C-NT-'));
  ok(libsequence::IsAlignment_Fasta($v));

=head2 sub Gapped_Fasta(data)

Returns:true if the vector contains a gap character ('-') , false otherwise.

  ok(libsequence::Gapped_Fasta($v)); 
  
=head2 sub RemoveGaps_Fasta(data)

Modifies the data vector to remove all positions that contain the gap character'-'.

  my $v1 = $v;
  libsequence::RemoveTerminalGaps_Fasta($v1);
  is($v1->get(0)->swig_second_get, 'T-CA');
  is($v1->get(1)->swig_second_get, 'C-NT');

=head2 sub UnGappedLength_Fasta(data)

Returns the number of sites in the alignment for which all objects do not contain the gap character '-'. If the data are not aligned,
the value Sequence::SEQMAXUNSIGNED is returned as an error

  is(libsequence::UnGappedLength_Fasta($v), 3);
    
=head2 sub Trim_Fasta(data, sites)

Returns a copy of the data vector, modified in the following way. The sites vector contains an even number of sites 
(whose values are sorted). If sites does not contain an even number of values Sequence::SeqException is thrown. If sites is 
empty, Sequence::SeqException is thrown. The values in sites represent a series of intervals that you wish to keep, and the 
return vector is consists only of those--i.e. all positions not present in the intervals defined in sites are lost.
For example, if you pass a vector<int> containing the values 0,10,21, and 30, then the data vector is modified so that positions 0 through 10 and 21 through 30 are all
that remains. One intended use of this function is to pull, for example, the coding region out of an aligned block.

Parameters:
sites 	vector<int> containing an even number of integers specifying the intervals of data to keep

  my $sites = new libsequence::intVector(2);
  $sites->set(0,0);
  $sites->set(1,2);
  is(libsequence::Trim_Fasta($v, $sites)->[0]->swig_second_get, 'T-C');
  is(libsequence::Trim_Fasta($v, $sites)->[1]->swig_second_get, 'C-N');
  
=head2 sub TrimComplement_Fasta(data,sites)

Returns a copy the data vector, modified in the following way. The sites vector contains an even number
of sites (whose values are sorted). If sites does not contain an even number of values. Sequence::SeqException is thrown. If 
sites is empty, Sequence::SeqException is thrown. The values in sites represent a series of intervals that you wish to keep, 
and the return vector consists only of sites not present in sites--i.e. all positions not present in the intervals defined in 
sites are kept. For example, if you pass a vector<int> containing the values 0,10,21, and 30, then the data vector is modified 
so that positions 11 through 20 and 31 through the end of the sequences are all that remains.
  
Parameters:
sites vector<int> containing an even number of integers specifying the intervals of data to throw away

  is(libsequence::TrimComplement_Fasta($v, $sites)->[0]->swig_second_get, 'A');
  is(libsequence::TrimComplement_Fasta($v, $sites)->[1]->swig_second_get, 'T');
  

=head2 sub RemoveFixedOutgroupInsertions_Fasta(data, sites, ref)

Removes all positions from data that for which the outgroup contains an insertion relative to ingroup

Parameters:
data 	a vector of Seq objects
site 	index of the site at which to begin (set to 0 usually)
ref 	the index of the outgroup in data

  my $nv = $v;
  libsequence::RemoveFixedOutgroupInsertions_Fasta($nv,0,3);
  is($nv->get(0)->swig_second_get, 'T-CA');
  is($nv->get(1)->swig_second_get, 'C-NT');  

=head2 sub validForPolyAnalysis_strPair(beg,end):

Returns:true if each element in the range [beg,end) only contains characters in the set {A,G,C,T,N,-}, false otherwise

>   my $beg = $v->begin();
>   my $end = $v->end();


=head1 Diverge Statics

=head2 class Kimura80

#=for POD::Tested reset

Kimura's 2-parameter distance

Kimura80(seqa, seqb): Constructor, seqa and seqb should be of the same length.

  my $fas1 = new libsequence::Fasta('dna1', 'AGTGCG');
  my $fas2 = new libsequence::Fasta('dna2', 'TGCACT');
  my $kim = new libsequence::Kimura80($fas1, $fas2);

K(): Returns: the distance between the two sequences.

  is($kim->K(), 0);
  
sites(): Returns:the number of sites compared, excluding gaps, missing data, etc.

  is($kim->sites(), 6, "TestSeties");


=head2 class GranthamWeights2

#=for POD::Tested reset

Weights paths by Grantham's distances for codons differing at 2 sites

GranthamWeights2(): Constructor

  my $gran2 = new libsequence::GranthamWeights2();
  
weights(): Returns:a double * of size 2 (1 value for each branch)

  my $weights2 = $gran2->weights();
  #my $a = new libsequence::doubleArray(2);
  #print $a;
  #my $y = $a->getitem(0);
  #my $w = libsequence::doubleArray->frompointer($weights2);



Calculate(): Calculate actually calculates the weights for each branch

  $gran2->Calculate('CGU', 'AGG');
  is(libsequence::doubleDeref($gran2->weights(),0), 0);
  
~GranthamWeights2(): Destructor

  $gran2->DESTROY;
  

=head2 class GranthamWeights3

Weights paths by Grantham's distances for codons differing at 3 sites.

GranthamWeights3():Constructor

  my $gran3 = new libsequence::GranthamWeights3();
  
weights(): Returns:a double * of size 6 (1 value for each branch)

  my $weights3 = $gran3->weights();
  
Calculate(): Calculate actually calculates the weights for each branch

  $gran3->Calculate('AAA', 'CCC');
  #print libsequence::doubleDeref($gran3->weights(),1);
  is(libsequence::doubleDeref($gran3->weights(),1), 0.15905190450646806);
  
~GranthamWeights3(): Destructor

  $gran3->DESTROY;
 
=head2 class Unweighted2

weights all pathways equally

  my $unwei2 = new libsequence::Unweighted2();
  
weights(): Returns:a double * of size 2 (1 value for each branch)

  my $unweights2 = $unwei2->weights();
  
Calculate(): Calculate actually calculates the weights for each branch

  $unwei2->Calculate('CGU', 'AGG');
  is(libsequence::doubleDeref($unwei2->weights(),0), 0.5);

  
~Unweighted2(): Destructor

  $unwei2->DESTROY;
  
=head2 class Unweighted3

weights all pathways equally

  my $unwei3 = new libsequence::Unweighted3();
  
weights(): Returns:a double * of size 6 (1 value for each branch)

  my $unweights3 = $unwei3->weights();
  
Calculate(): Calculate actually calculates the weights for each branch

  $unwei3->Calculate('AAA', 'CCC');
  is(libsequence::doubleDeref($unwei3->weights(),0), 0.16666666666666666);
 
~Unweighted3(): Destructor

  $unwei3->DESTROY;
  

=head2 class RedundancyCom95

Calculate redundancy of a genetic code using Comeron's counting scheme

RedundancyCom95(): Constructor

  my $redun = new libsequence::RedundancyCom95();
  
FirstNon(): Returns:number of times the first codon position is non-degenerate

Precondition:codon is of length 3, is all uppercase, and only contains the characters {A,G,C,T}
Exceptions:Sequence::SeqException if precondition is not met

  is($redun->FirstNon('CGA'), 0.5);
  
First2S(): Return number of times the first codon position is synonymous via a transition

  is($redun->First2S('TTT'), 0.0);
  
First2V(): Return number of times the first codon position is synonymous via a transversion

  is($redun->First2V('AGG'), 0.33333333333333331);
  
ThirdNon(): Returns the number of times the third position is non-degenerate

  is($redun->ThirdNon('AGA'), 0.0);
  
ThirdFour(): Returns number of times the third position is fourfold-degenerate

  is($redun->ThirdFour('CGG'), 1.0);
  
Third2S(): Returns number of times the third position is synonymous via a transition

  is($redun->Third2S('AGG'), 1.0);
  
Third2V(): Returns number of times the third position is synonymous via a transversion

  is($redun->Third2V('AGG'), 0.0);
  
L0_vals(): Returns the number of non-degenerate positions in codon

  is($redun->L0_vals('CGG'), 1.6666666666666667);
  
L2S_vals(): Returns the number of transitional silent sites in codon

  is($redun->L2S_vals('AGG'), 1.0);
  
L2V_vals(): Returns the number of transversional silent sites in codon

  is($redun->L2V_vals('AGG'), 0.33333333333333331);
  
L4_vals(): Returns the number of fourfold silent sites in codon

  is($redun->L4_vals('CGG'), 1.0);
  
~RedundancyCom95(): Destructor

  $redun->DESTROY;
  
=head2 class Sites

Calculate length statistics for divergence calculations

Sites(): Constructor

Sites(sitesObj, seq1, seq2, max = 3, code = 0)
Parameters:
sitesObj 	an initialized object of type RedundancyCom95
seq1 	a Seq object
seq2 	a Seq object
max 	max number of substitutions per codon to analyze
code 	see Sequence::GeneticCodes for valid values

Note:
sequences must be of same length, this is checked by assert()
sequence lengths must be multiples of 3, this is checked by assert()

  my $redun = new libsequence::RedundancyCom95();
  my $seq1 = new libsequence::Fasta('n1', 'AGTGCC');
  my $seq2 = new libsequence::Fasta('n2', 'TTGCAG');
  my $sites = new libsequence::Sites($redun, $seq1, $seq2);
  
L0(): Returns alignment length in terms of non-degenerate sites

  is($sites->L0(), 3.5);
  
L2S(): Returns alignment length in terms of transitional-degenerate sites

  is($sites->L2S(), 2.0);
  
L2V(): Returns alignment length in terms of transversional-degenerate sites

  is($sites->L2V(), 0.0);
  
L4(): Returns alignment length in terms of fourfold-degenerate sites

  is($sites->L4(), 0.5);
  
~Sites(): Destructor

  $sites->DESTROY;
  
=head2 class SingleSub

Deal with codons differing at 1 position.

SingleSub(): Constructor

  my $sinsub = new libsequence::SingleSub();
  
operator (sitesObj, cod1, cod2): A functor to obtain divergence statistics for Comeron's method for codons that 
differ at one position. 

Parameters:
cod1 	a std::string of length 3 representing a codon
cod2 	a std::string of length 3 representing a codon
Note:
cod1 and cod2 lengths are verified by assert() and consist of A,T,C,G

  my $redun = new libsequence::RedundancyCom95();
  $sinsub->__call__($redun, 'CAC', 'AAT');
  
P0(): Returns number of transitions at non-degenerate sites in the codon

  is($sinsub->P0(), 0);

P2S(): Returns number of transitions at transitional-degenerate sites in the codon

  is($sinsub->P2S(), 1);

P2V(): Returns number of transitions at transversional-degenerate sites in the codon

  is($sinsub->P2V(), 0);

P4(): Returns number of transitions at fourfold-degenerate sites in the codon

  is($sinsub->P4(), 0);
  
Q0(): Returns number of transversions at non-degenerate sites in the codon

  $sinsub->__call__($redun, 'TAG', 'AAC');
  is($sinsub->Q0(), 0);

Q2S(): Returns number of transversions at transitional-degenerate sites in the codon

  is($sinsub->Q2S(), 0.5);
  
Q2V(): Returns number of transversions at transversional-degenerate sites in the codon

  is($sinsub->Q2V(), 0);

Q4(): Returns number of transversions at fourfold-degenerate sites in the codon

  is($sinsub->Q4(), 0.5);

~SingleSub(): Destructor

  $sinsub->DESTROY;

=head2 class TwoSubs

Deal with codons differing at 2 positions.

TwoSubs(): Constructor

  my $twosubs = new libsequence::TwoSubs();
  
operator (): A function object to obtain divergence statistics for Comeron's method for codons that differ at two 
positions. Alternate paths are weighted by Grantham's distances.
  
Parameters:
sitesObj 	an initialized object of type Sequence::RedundancyCom95
codon1 	string of length 3 representing nucleodites
codon2 	string of length 3 representing nucleodites
weights2 	a weighting scheme for the pathways

  my $gran2 = new libsequence::GranthamWeights2();
  $twosubs->__call__($redun, 'TCT', 'CAG', $gran2);
  
P0(): Returns number of transitions at non-degenerate sites in the codon

  is($twosubs->P0(), 0.61963011456326567);
  
P2S(): Returns number of transitions at transitional-degenerate sites in the codon

  is($twosubs->P2S(), 0);
  
P2V(): Returns number of transitions at transversional-degenerate sites in the codon

  is($twosubs->P2V(), 0);
  
P4(): Returns number of transitions at fourfold-degenerate sites in the codon

  is($twosubs->P4(), 0);
  
Q0(): Returns number of transversions at non-degenerate sites in the codon

  $twosubs->__call__($redun, 'CCT', 'AAG', $gran2);
  is($twosubs->Q0(), 0.97042355598595176);
  
Q2S(): Returns number of transversions at transitional-degenerate sites in the codon

  is($twosubs->Q2S(), 0.77218233301053618);
  
Q2V(): Returns number of transversions at transversional-degenerate sites in the codon


  is($twosubs->Q2V(), 0);
  
Q4(): Returns number of transversions at fourfold-degenerate sites in the codon

  is($twosubs->Q4(), 0.25739411100351206);

~TwoSubs(): Destructor

  $twosubs->DESTROY;

=head2 class ThreeSubs

Deal with codons differing at all 3 positions.

ThreeSubs(): Constructor

  my $trisubs = new libsequence::ThreeSubs();
  
operator (): A function object to obtain divergence statistics for Comeron's method for codons that differ at three 
positions. Alternate paths are weighted by Grantham's distances.
  
Parameters:
sitesObj 	an initialized object of type Sequence::RedundancyCom95
codon1 	string of length 3 representing nucleodites
codon2 	string of length 3 representing nucleodites
weights3 	a weighting scheme for the pathways

  my $gran3 = new libsequence::GranthamWeights3();
  $trisubs->__call__($redun, 'ATG', 'CGA', $gran3);
  
P0(): Returns number of transitions at non-degenerate sites in the codon

  is($trisubs->P0(), 0.15683540643876337);
  
P2S(): Returns number of transitions at transitional-degenerate sites in the codon
 
  is($trisubs->P2S(), 0.19184735131118127);
  
P2V(): Returns number of transitions at transversional-degenerate sites in the codon

  is($trisubs->P2V(), 0.15683540643876337);
  
P4(): Returns number of transitions at fourfold-degenerate sites in the codon

  is($trisubs->P4(), 0.49448183581129201);
  
Q0(): Returns number of transversions at non-degenerate sites in the codon

  is($trisubs->Q0(), 1.4183875193488655);
  
Q2S(): Returns number of transversions at transitional-degenerate sites in the codon

  is($trisubs->Q2S(), 0.22654016803768418);
  
Q2V(): Returns number of transversions at transversional-degenerate sites in the codon


  is($trisubs->Q2V(), 0.3550723126134504);
  
Q4(): Returns number of transversions at fourfold-degenerate sites in the codon

  is($trisubs->Q4(), 0.0);
  
~ThreeSubs(): Destructor

  $trisubs->DESTROY;
  

=head2 class Comeron95

#=for POD::Tested reset

an object to implement Comeron's (1995) method to calculate Ka and Ks
        
Comeron95(seqa, seqb, max = 3, code = UNIVERSAL, _weigths2 = NULL, _weights3 = NULL): 
Constructor, initialize and calculate synonymous and nonsynonymous distances between two sequence objects
Parameters:
seqa 	an object of type or derived from type Sequence::Seq
seqb 	an object of type or derived from type Sequence::Seq
max 	maximum number of substitutions per codon to allow in the analysis
code 	genetic code, see Sequence::GeneticCodes
_weights2 	a weighting scheme for codons differing at 2 positions. If NULL, Sequence::GranthamWeights2 is used
_weights3 	a weighting scheme for codons differing at 3 positions. If NULL, Sequence::GranthamWeights3 is used

Warning:
Note that the pointers to weighting schemes are dumb pointers.
This allows me to check for NULL and then assign a default.
If you use your own classes, make sure they clean up after themselves if they throw exceptions!!!

Exceptions:
if sequence lengths are not equal or if sequence lengths are not multiples of 3
exception will be rasied

  my $seq1 = new libsequence::Fasta('s1', 'GCTACGAGC');
  my $seq2 = new libsequence::Fasta('s2', 'CTTCGGTAG');
  
  my $comeron = new libsequence::Comeron95($seq1, $seq2);
  
ka(): Returns the nonsynonymous distance

  is($comeron->ka(), 0);
  
ks(): Returns the synonymous distance

  is($comeron->ks(), 0.39270813010733246);
  
ratio(): Returns ka/ks

  is($comeron->ratio(), 0);
  
P0(): Returns number of transitions at nondegenerate sites

  is($comeron->P0(), 2.0);
  
P2S(): Returns number of transitions at 2-fold, transitional degenerate sites

  is($comeron->P2S(), 0);
  
P2V(): Returns number of transitions at 2-fold, transversional degenerate sites

  is($comeron->P2V(), 0);
  
P4(): Returns number of transitions at 4-fold degenerate sites

  is($comeron->P4(), 0);
  
Q0(): Returns number of transversion at nondegenerate sites

  is($comeron->Q0(), 3.9044719537318398);
  
Q2S(): Returns number of transversion at 2-fold, transitional degenerate sites

  is($comeron->Q2S(), 0.75747679019931624);
  
Q2V(): Returns number of transversion at 2-fold, transversional sites

  is($comeron->Q2V(), 0.17659143153111975);
  
Q4(): Returns number of transversion at 4-fold degenerate sites

  is($comeron->Q4(), 0.16145982453772428);
  
aa(): Returns corrected nonsynonymous divergence at tranversioal- and non- degenerate sites

  is($comeron->aa(), 0);
  
As(): Returns corrected synonymous divergence at transitional-degenerate sites

  is($comeron->As(), 0.205690523739009);
  
bs(): Returns corrected nonsynonymous divergence at tranversioal- and non- degenerate sites 

  is($comeron->bs(), 0.18701760636832385);
  
ba(): Returns corrected nonsynonymous divergence at transitional- and non- degenerate sites
 
  is($comeron->ba(), 0);
  
L0(): Returns the number of nondegenerate sites compared

  is($comeron->L0(), 4.8333333333333339);
  
L2S(): Returns the number of twofold, transitional-degenerate sites compared

  is($comeron->L2S(), 0.5);
  
L2V(): Returns the number of twofold, transversional-degenerate sites compared

  is($comeron->L2V(), 0.16666666666666666);
  
L4(): Returns the number of 4-fold degenerate sites compared

  is($comeron->L4(), 2);
  
~Comeron95(): Destructor

  $comeron->DESTROY;
  


=head1 Classes and functions to aid in the calculations of the pathways between two condons

This group of classes and functions deals with determining either the counts of silent and replacement 
differences between codons or the intermedate codons that occurs between two different codons
  
=head2 class shortestPath

Calculate shortest path between 2 codons. The length of a path is in terms of the sum
of the Grantham's distances along it's branches.

shortestPath(codon1, codon2, code = UNIVERSAL): Constructor
Parameters:
codon1 	a std::string of length 3
codon2 	a std::string of length 3
code 	which genetic code to use

Precondition:
(codon1.length() == 3 && codon2.length() ==3)
Note:
If either codon1 or codon2 contain characters other than {A,G,C,T}, the pathway type will be assigned shortestPath::AMBIG

  my $path = new libsequence::shortestPath('ATG', 'ACG');

type(): Returns:a value from the enum type shortestPath.pathType representing the type of the shortest path.
Note:enum   pathType { 
                              S, N, SS, SN, 
                              NN, SSS, SSN, SNN, 
                              NNN, NONE, AMBIG 
                            }
                            
  is($path->type(), 1);
  
path_distance(): Returns the total Grantham's distance of the shortest path

  is($path->path_distance(), 81.039692790000004);
  
~shortestPath(): Destructor

  $path->DESTROY;
  
=head2 sub Intermidates2(intermediates, codon1, codon2)

Calculate the intermediate codons between a pair of codons diverged at 2 positions.

Parameters:
intermediates 	a string[2] in which we will place the intermediate codons
codon1 	a codon
codon2 	a codon

  my $c = new libsequence::stringArray(2);
  libsequence::Intermediates2($c, 'ATG', 'CGG');
  is($c->getitem(0), 'CTG');
  is($c->getitem(1), 'AGG');
  
=head2 sub Intermidates3(intermediates, codon1, codon2)

Calculate the intermediate codons between a pair of codons diverged at 3 positions.

Parameters:
intermediates 	a string[9] in which we will place the intermediate codons
codon1 	a codon
codon2 	a codon

  my $c = new libsequence::stringArray(9);
  libsequence::Intermediates3($c, 'ACG', 'CTT');
  is($c->getitem(0), 'CCG');
  is($c->getitem(3), 'ATG');
  is($c->getitem(5), 'ATT');
  is($c->getitem(8), 'ATT');

=head2 mustShortestPath():

Returns a std::pair<unsigned,unsigned> representing the number of silentand replacement changes b/w 2 codons, as 
calculated by shortestPath. The first member of the pair is the number of silent changes in the shortest path, and 
the second the number of replacement changes. If the pathway type is shortestPath::AMBIG, both members of the return 
value will be equal to SEQMAXUNSIGNED, which is declared in <Sequence/SeqConstants.hpp>

 my $path = libsequence::mutsShortestPath('AAA','GGG');
 is($path->swig_first_get, 1);
 is($path->swig_second_get, 2);

=head1 Function objects defined in the library

=head2 class stateCounter

keep track of state counts at a site in an alignment or along a sequence

stateCounter(): Constructor

  my $states = new libsequence::stateCounter();
  
operator (): function call, add the character in position i,j in an alignment
characters are from {A, T, G, C, N, 0, 1, -}

  $states->__call__('A');
  is($states->{a}, 1);
  $states->__call__('C');
  is($states->{c}, 1);
  $states->__call__('C');
  is($states->{c}, 2);

nStates(): Returns the number of states counted, excluding gaps and missing data

  $states->__call__('g');
  $states->__call__('n');
  $states->__call__('0');
  $states->__call__('-');
  is($states->nStates(), 4);
  
  
  
=head1 Miscellany

=head2 sub Translate(beg, end, genetic_code = UNIVERSAL, gapchar = '-')

Returns:a string representing the translation of the range
Translate(beg, end, genetic_code = UNIVERSAL, gapchar = '-')
Parameters:
beg 	a pointer to the beginning of the region to translate
end 	a pointer to 1 past the end of the region to translate
genetic_code 	must be a value from the enumeration list Sequence::GeneticCodes
gapchar 	a character representing an alignment gap

  my $seq = new libsequence::Fasta('dna', 'atcgatcct');
  my $beg = $seq->begin_const();
  my $end = $seq->end_const();
  is(libsequence::Translate($beg,$end), 'IDP');


=head2 sub TsTv(i, j)

akes two chars, assumed to be nucleotides. The integer returned by this function is a
member of the enumeration type Mutations.

  is(libsequence::TsTv('A', 'G'), 1);
  
Takes two ints, assumed to be integer representations of nucleotides.The way to ensure that
the int represents a nucleotide in a valid way is to use Nucleotides. The return value is
determined by a call to TsTv(int i, int j), where the ints are defined in turn by Nucleotides

  is(libsequence::TsTv(1, 2), 2);
  
=head2 sub Different(seq1, seq2, skip_missing = 1, nucleic_data = 1)

Ask if two strings are different. While this can normally be done by asking if (seq1 != seq2) {},
missing data poses a problem here. If skip-missing == 1, missing data (the 'N' character
for nucleotide data, 'X' for amino acid) are not used to determine if the sequences are different.
If nucleic_acid ==1, nucleotide data are assumed, if nucleic_acid==0, protein data are assumed.
Returns 1 if the seqs are different, 0 otherwise. If the two sequences are of different length, true is returned.

  ok(libsequence::Different('ATGNT', 'ATGT', 1, 1));
  ok(!libsequence::Different('CCN', 'CCT', 1, 1));
  
=head2 sub Gapped(data) or sub Gapped(beg, end, gapchar='-')

Returns 1 if the string contains gaps, 0 otherwise
Note: The only gap character checked so far is '-'. Use template version for other gap characters

  ok(libsequence::Gapped('A-G-T'));
  
Parameters:
beg 	an iterator
end 	an iterator
gapchar 	a character representing an aligment gap
Returns:true if gapchar is present in the range [beg,end), false otherwise
  
  my $fasta = new libsequence::Fasta('seq', 'A++GTC');
  my $beg = $fasta->begin();
  my $end = $fasta->end();
  
  ok(libsequence::Gapped($beg,$end,'+'));


=head2 sub NotAGap()  

Returns true if a c is not a gap character, false otherwise.
Note: Currently, only '-' is considered to be a gap character

  ok(!libsequence::NotAGap('-'));

=head2 sub NumDiffs(seq1, seq2, skip_missing = 1, nucleic_acid = 1)

Returns:the number of differences between two std::strings.
Can skip missing data in the same fashion as Comparisons::Different.
If one sequence is shorter than the other, the number of positions compared is the length of the shorter sequence.

  is(libsequence::NumDiffs('AATGC-CT', 'A-T-CCGT'), 4);
  
=head2 class ambiguousNucleotide()

judge if a char is ambigousNuclectide. In other words,
if char(can be lower letter) is not within{A,T,G,C},Return 0 if it is, otherwise 1

  my $amb = new libsequence::ambiguousNucleotide();
  ok(!($amb->__call__('A')));
  
=head2 class invalidPolyChar():

This functor can be used to determine if a range contains characters that the SNP analysis routines in this library 
cannot handle gracefully if char (can be lower letter) is not within{A,T,G,C,N,-,.},Return False if it is, otherwise Ture

  my $inv = new libsequence::invalidPolyChar();
  ok($inv->__call__('F'));

=head1 Molecular Population Genetics

=head2 class segment

A portion of a recombining chromosome.

segment(): Default Constructor

  my $seg_null = new libsequence::segment();

segment(beg, end, desc = 0): Constructor.
Parameters:
beg: the first site in the segment
end: the last site in the segment
desc: the individual in the sample to which the segment leads
  
  my $seg = new libsequence::segment(1, 3, 0);
  
=head2 class chromosome

A chromosome is a container of segments. 

chromosome(): Default constructor.

  my $chro_null = new libsequence::chromosome();

chromosome(initial_segs, population = 0): Constructor
Parameters:
initial_segs 	a vector of segments
population 	used to set pop

  my $segs = new libsequence::segVector(3);
  my $seg1 = new libsequence::segment();
  $segs->set(0,$seg1);
  my $seg2 = new libsequence::segment(1,4,0);
  $segs->set(1,$seg2);
  my $seg3 = new libsequence::segment(1,3,1);
  $segs->set(2,$seg3);
  my $chro = new libsequence::chromosome($segs);
  #$segs{0} = new libsequence::segment();

chromosome(chroObj):Copy constructor

  my $copy_chro = new libsequence::chromosome($chro);
  
first(): Returns the first position in the chromosome

  is($chro->first(), 0);
  
last(): Returns the last position in the chromosome

  is($chro->last(), 3);
  
links(): Computes and returns the number of positions at which recombination can occur 
in the chromosome. Returns (segs+nsegs-1)->end - segs->beg.

  is($chro->links(), 3);
  
swap_with(): Swaps the data members of the current chromosome with chromosome ch. Called by the coalesce routine, 
and is necessary to prevent nastiness such as multiple calls to free when vectors of chromosomes go out of scope. 
Implemented as: std::swap(this->segs,ch.segs); std::swap(this->nsegs,ch.nsegs); std::swap(this->pop,ch.pop);

  my $segs1 = new libsequence::segVector(2);
  my $seg11 = new libsequence::segment(2,5,0);
  $segs1->set(0,$seg11);
  my $seg12 = new libsequence::segment(1,8,1);
  $segs1->set(1,$seg12);
  my $chro1 = new libsequence::chromosome($segs1);
  
  $chro->swap_with($chro1);
  is($chro->first(), 2);
  
assign_allocated_segs(newsegs, new_nsegs)
Parameters:
newsegs 	an array of segments allocated with malloc
new_nsegs 	the number of segs stored in newsegs

  my $newsegs = new libsequence::segArray(2);
  
  my $new1 = new libsequence::segment(3,4,1);
  my $new2 = new libsequence::segment(2,5,0);
  $newsegs->setitem(0, $new1);
  $newsegs->setitem(1, $new2);
  
  my $newchro = $chro;
  $newchro->assign_allocated_segs($newsegs, 2);
  is($newchro->first(), 3);
  
  
~chromosome(): Destructor

  $chro->DESTROY();
  
=head2 class HKAdata

Data from a single locus for an HKA test.

HKAdata(): Default constructor

  my $hka_null = new libsequence::HKAdata();
  
HKAdata(sa, sb, d, na, nb): Constructor
sa 	Num. polymorphic sites in species a
sb 	Num. polymorphic sites in species b
d 	Divergence between species a and b (per locus)
na 	sample size for species a
nb 	sample size for species b
  
  my $hka = new libsequence::HKAdata(3,5,2,1,1);
  
HKAdata(hkaObj): Copy contructor

  my $hka_copy = new libsequence::HKAdata($hka);
  
=head2 sub calcHKA(data):

Performs the calculations necessary for the HKA test.Returns an object of type multiLocusHKAparams.
Parameters:
data 	a vector of HKAdata objects

  my $hv = new libsequence::hkaVector(3);
  $hv->set(0, libsequence::HKAdata->new());
  $hv->set(1, libsequence::HKAdata->new(3,5,2,1,1));
  $hv->set(2, libsequence::HKAdata->new(4,8,10,5,0));
  my $hkaRes = libsequence::calcHKA($hv);
  
=head2 class node

A point on a marginal tree at which a coalescent event occurs.

Parameters:
t 	The (coalescent-scaled) time at which the node was generated
a 	The index in the marginal tree that is the ancestor of the current node
      
  my $node = new libsequence::node();
  
  
=head2 class marginal

The genealogy of a portion of a chromosome on which no recombination has occurred.
A marginal history is a coalscent tree for a region in which no recombination has occured in the history of a sample.
        
marginal(beg, nsam, nnodes, tree): 
Parameters:
marginal(beg, nsam, nnodes, tree)
beg:The (mutational) site at which the current marginal tree begins
nsam: The sample size being simulated. The 2*nsam-1 nodes in the tree are therefore indexed from 0 to 2*nsam-2
nnodes: The current number of nodes in the tree
tree: the coalescent history of this marginal tree

  my $tree = new libsequence::nodeVector(3);
  my $n1 = new libsequence::node();
  my $n2 = new libsequence::node(1,3);
  my $n3 = new libsequence::node(3,10);
  $tree->set(0, $n1);
  $tree->set(1, $n2);
  $tree->set(2, $n3);
  my $marg = new libsequence::marginal(5, 10, 19, $tree);
  
operator <: Returns marginalObj1.beg < marginalObj.beg

  my $tree1 = new libsequence::nodeVector(1);
  $tree1->set(0, $n1);
  my $marg1 = new libsequence::marginal(1,5,10,$tree1);
  ok($marg1 < $marg);

 
operator []: Returns node in tree with index i

  is($marg->__getitem__(0)->{time}, 0);
  
=head2 class newick_stream_marginal_tree

Class that provides a typecast-on-output of a marginal tree to a newick tree 

newick_stream_marginal_tree(marg):Constructor
marg: a mariginal tree

  my $imarg = libsequence::init_marginal(10);
  my $n = new libsequence::newick_stream_marginal_tree($imarg);
  
get_tree():if a tree has been read in from a stream, return it, else return an empty tree

  my $tree = $n->get_tree();


> =head2 class SimParams:
> 
> Parameters for Hudson's simulation program
> 
> SimParams(): Constructor
> 
>   my $para = new libsequence::SimParams();
>   
> params(): Returns the command-line input to ms
> 
>   $para->params();
>   
> totsam(): Returns the total sample size (# gametes)
> 
>   is($para->totsam(), 0);
>   
> runs(): Returns number of genealogies to generate
> 
>   is($para->runs(), 0);
> 
> 
> =head2 class SimData:
> 
> Data from coalescent simulations.
> 
> SimData(nsame = 0, nsnps = 0): Default Constructor
> nsama    sample size
> 
>   my $sdata = new libsequence::SimData();
>   
> SimData(pos, dat)
> Parameters:
> pos     vector of doubles representing segregating positions
> dat     vector of strings representing sequence data.
> 
>   my $pos = new libsequence::doubleVector(4);
>   $pos->set(0, .25);
>   $pos->set(1, .32);
>   $pos->set(2, .34);
>   $pos->set(3, .44);
>   my $dat = new libsequence::strVector(2);
>   $dat->set(0, 'A-TC');
>   $dat->set(1, 'N0G1');
>   my $d = new libsequence::SimData($pos,$dat);
>   
> SimData(sbegin, send)
> 
>   my $beg = $d->sbegin();
>   my $end = $d->send();
>   my $d1 = new libsequence::SimData($beg,$end);
>   
> empty():Returns true if object contains no data, false otherwise
> 
>   ok($sdata->empty());
>   
> GetData():Returns PolyTable::data, a vector of std::strings containing polymorphic sites. Assuming the vector is returned 
> to a vector<string> called data, accessing data[i][j] accesses the j-th site of the i-th sequence
> 
>   is($d->GetData()->[0], 'A-TC');
>   is($d->GetData()->[1], 'N0G1');
>  
> GetPositions(): Returns PolyTable::positions
> 
>   is($d->GetPositions()->[1], .32);
>   is($d->GetPositions()->[3], .44);
> 
> assign(): Returns true if the assignment was successful, false otherwise. The only case where false is returned is if the 
> number of individuals at each site is not the constan from beg to end.
> 
>   my $d2 = new libsequence::SimData();
>   ok($d2->assign($beg, $end));
>   
> RemoveMissing(): go through the data and remove all the sites with missing data (the character N).
> 
>   $d1->RemoveMissing();
>   is($d1->GetData()->[1], '0G1');
>   is($d1->GetData()->[0], '-TC');
>   
> RemoveAmbiguous():go through the data and remove all the sites with states other than {A,G,C,T,N,0,1,-}
> 
>   $dat->set(1, 'NEG1');
>   my $d3 = new libsequence::SimData($pos, $dat);
>   $d3->RemoveAmbiguous();
>   is($d3->GetData()->[0], 'ATC');
>   is($d3->GetData()->[1], 'NG1');
>   
> RemoveMultiHits(skipOutgroup = False, outgroup = 0): go through the data and remove all the sites with more than 2 states 
> segregating. By default, this routine also removes sites where there are 2 states segregating in the ingroup. and the 
> outgroup (if present) has a 3rd state.
> Parameters:
> skipOutgroup 	default is false. If true, the character state of the outgroup is ignored.
> outgroup 	the index of the outgroup in the data vector
> 
>   my $dat2 = new libsequence::strVector(3);
>   $dat2->set(0, 'A-TC');
>   $dat2->set(1, 'N0G1');
>   $dat2->set(2, 'T-CC');
>   my $d4 = new libsequence::SimData($pos,$dat2);
>   $d4->RemoveMultiHits();
>   is($d4->GetData()->[0], 'A-C');
>   is($d4->GetData()->[1], 'N01');
>   is($d4->GetData()->[2], 'T-C');
>   
> ApplyFreqFilter(mincount, haveOutgroup = False, outgroup = 0): go through the data and remove all positions where there is a 
> variant at count (# of occurences in the sample) < minfreq
> Parameters:
> mincount 	minimum count of a variant in the data. Variants that occur < mincount times are thrown out.
> haveOutgroup 	true if an outgroup is present in the data, false otherwise
> outgroup 	the index in the data array containing the outgroup (if present)
> 
>   $d4->ApplyFreqFilter(2);
>   is($d4->GetData()->[0], '');
>   
> Binary(haveOutgroup = false, outgroup = 0, strictInfSites = true)
> Parameters:
> haveOutgroup 	use true if an outgroup is present, false otherwise
> outgroup 	the index of the outgroup in the data vector used to construct the object
> strictInfSites 	if true, throw out all sites with > 2 character states (including outgroup!)
> 
> Note:
> if haveOutgroup== true, then 0 means an ancestral state and 1 a derived state in the resulting. 
> note If haveOutgroup == true, and there are sites with missing data in the outrgroup sequence,
> those sites are removed from the data, since its assumed you actually want to know ancestral/derived
> for every site
> 
>   $d3->Binary();
>   is($d3->GetData()->[0], 'ATC');
> 
> segsites(): Returns the number of segregating sites in the data block
> 
>   is($d->segsites(), 4);
>   
> size(): Return how many std::strings are stored in PolyTable::data
> 
>   is($d->size(), 2);
>   
> numsites(): Returns number of sites
> 
>   is($d->numsites(), 4);
>   
> position():Return the i-th position from the PolyTable::positions.
> 
>   is($d->position(2), 0.34);
>   
> operator =: Returns true if two SimData object are the same, otherwise false
> 
>   ok($d == $d2);
>   
> operator !=:Returns False if two SimData object are the same, otherwise True
> 
>   ok($d1 != $d3);
>   
> operator []:Return the i-th element of PolyTable::data.
> 
>   is($d->__getitem__(0), 'A-TC');
>   
> ~SimData(): Destructor
> 
>   $d->DESTROY();
>   
> 
> =head2 class PolySites()
> 
> Polymorphism tables for sequence data. 
> 
> PolySites(alignment, strictInfsites = 0, ignoregaps = 1, skipMissing = False, skipAdjSNP = False, freqfilter = 0): This is the
> constructor if you are using "string-like" data, such as std::string, or Sequence::Fasta. Note that the vector name is aligment,
> and that means that every sequence had better be the same length!
> 
> Parameters:
> alignment 	vector of data
> strictInfSites 	if true, throw out all sites with > 2 states
> ignoregaps 	if true, do not count gapped sites as polymorphisms
> skipMissing 	if true, ignore ALL sites with missing data ('N')
> skipAdjSNP 	if does nothing. a placeholder for a future feature
> freqfilter 	Defaults to 0. For a polymorphic site to be included in the final table,
> the minor allele count in the data (i.e. the number of times the minor allele occurs at that site)
> must be strictly greater than freqfilter
> 
> Note:
> segsite positions are stored as positions (starting from 1)
> 
> Warning:
> when ignoregaps=false, this class does not do the right thing
> 
>   my $v = new libsequence::fastaVector(2);
>   $v->set(0, libsequence::Fasta->new('s1', 'ANTGC-C'));
>   $v->set(1, libsequence::Fasta->new('s2', '-GGTCCA'));
>   my $p = new libsequence::PolySites($v);
>   
> PolySites(List, stringList):
> Parameters:
> List 	a list of doubles representing positions of polymorphic positions
> stringList 	a vector of strings representing the polymorphic characters
> 
>   my $l = new libsequence::doubleVector(2);
>   $l->set(0, 0);
>   $l->set(1, 4);
>   my $strl = new libsequence::strVector(2);
>   $strl->set(0, 'ATG-');
>   $strl->set(1, 'CCCT');
>   my $p1 = new libsequence::PolySites($l, $strl);
>   
> GetData():Returns PolyTable::data, a vector of std::strings containing polymorphic sites. Assuming the vector is returned to 
> a vector<string> called data, accessing data[i][j] accesses the j-th site of the i-th sequence
> 
>   is($p->GetData()->[0], 'TGC');
>   is($p->GetData()->[1], 'GTA');
>   
> GetPositions(): Returns PolyTable::positions.
> 
>   is($p->GetPositions()->[0], 3.0);
>   is($p->GetPositions()->[1], 4.0);
>   is($p->GetPositions()->[2], 7.0);
>   
> empty(): Returns true if object contains no data, false otherwise
>   
>   ok($p1->empty());
>   
> size(): Return how many std::strings are stored in PolyTable::data
> 
>   is($p->size(), 2);
>   
> numsites(): Return how many positions are stored in PolyTable::positions
> 
>   is($p->numsites(), 3);
>   
> Binary(): Recode the polymorphism table in 0,1 (binary notation)
>             
>   $p->Binary();
>   is($p->GetData->[0], '000');
>   is($p->GetData->[1], '111');
> 
> ApplyFreqFilter(mincount, haveOutgroup = False, outgrp = 0): go through the data and remove all positions where there is a 
> variant at count (# of occurences in the sample) < minfreq
> Parameters:
> mincount 	minimum count of a variant in the data. Variants that occur < mincount times are thrown out.
> haveOutgroup 	true if an outgroup is present in the data, false otherwise
> outgroup 	the index in the data array containing the outgroup (if present)
> 
>   $p->ApplyFreqFilter(2);
>   ok($p->empty());
>   
> ~PolySites(): Destructor
> 
>   $p->DESTROY();
>   
> =head2 sub rotatePolyTable(fastaVecObj)
> 
> Return how many positions are stored in PolyTable::positions
> 
>   my $v = new libsequence::fastaVector(2);
>   $v->set(0, libsequence::Fasta->new('s1', 'ATGCG'));
>   $v->set(1, libsequence::Fasta->new('s2', 'CG-TT'));
>   my $p = new libsequence::PolySites($v);
>   
>   my $psv = libsequence::rotatePolyTable($p);
>   is($psv->[0]->swig_first_get, 1);
>   is($psv->[0]->swig_second_get, 'AC');
>   is($psv->[3]->swig_first_get, 5);
>   is($psv->[3]->swig_second_get, 'GT');

  
  
  
=head2 sub isseg(beg, nsegs, offset, pos)

ask if a chromosome beginning at seg and containing nsegs contains a segment containing the position pos.  Returns true if a segment
exists that contains the point pos

Parameters:
seg 	a pointer to a segment of a chromosome (this should be the 1st segment, such as the return value of chromosome::begin())
nsegs 	the number of segs in the chromosome pointed to by seg
offset 	a pointer to an integer. This integer is used for repeated pointer arithmetic, and should be initalized to 0 before the first call.
pos 	a position a long a chromosome. This function asks if pos is contained in the ancestral material of the chromosome whose segments begin at seg

  my $segs = new libsequence::segVector(3);
  $segs->set(0, libsequence::segment->new(1,4,0));
  $segs->set(1, libsequence::segment->new());
  $segs->set(2, libsequence::segment->new(2,8,1));
  my $chro = new libsequence::chromosome($segs);
  my $seg = $chro->begin();
  my $offset = new libsequence::intPointer();
  $offset->assign(0);
  ok(libsequence::isseg($seg,3,1,$offset));
  
=head2 sub calculate_scales(fragments, sample_scale, mutation_scale)

This is a helper function that rescales physical distance in base pairs to continuous distance on the interval 0,1.

Parameters:
fragments 	A vector of pairs, representing physical distance in bp. For each pair, the first element is the distance to the next 
fragment,and the second element is the length of the fragment. For example,two 1kb fragments separated by 10kb would be represented 
by the pairs (0,1000) (10000,1000).

sample_scale 	This vector will be filled with values representing the positions of the fragments on the continuous interval, without
any space betwen them. This is because we will actually do the simulation using a non-uniform genetic map to represent the high
recombination rates between fragments

mutation_scale 	This is a direct mapping of the data contained in fragments to the continuous scale, and can be used to rescale the positions of mutations

  my $fragments = new libsequence::fragVector(3);
  $fragments->push(libsequence::intPair->new(0,500));
  $fragments->push(libsequence::intPair->new(1000,500));
  $fragments->push(libsequence::intPair->new(1000,500));
  my $sample = new libsequence::scaleVector(3);
  my $mutation = new libsequence::scaleVector(3);
  libsequence::calculate_scales($fragments,$sample,$mutation);
  
=head2 sub sample_length(fragments)

When simulating partially linked regions, return the total length of sample material that we are simulating. Returns The sum of 
fragments[i].second for i=0 to i=fragments.size()-1

  is(libsequence::sample_length($fragments), 1500);
  
=head2 sub total_length(fragments)

When simulating partially linked regions, return the total length of the region. Returns The sum of fragments[i].first + fragments[i].second
for i=0 to i=fragments.size()-1

  is(libsequence::total_length($fragments), 3500);
  
=head2 sub init_sample(pop_config, nsites)

A simple function to initialize a sample of chromosomes. Returns a vector of chromosome.

Parameters:
pop_config 	For a k-population model, this vector contains the sample size for each pop. Individuals are labeled as beloning to 
population 0 to k-1, in the order specified in this vector
nsites 	The number of sites at which mutations occur. For a k-site model,recombination occurs at any of the k-1 "links" between 
sites. Eaach chromosome is assigned a single segment starting at position 0 and ending at nsites-1.

  my $intv = new libsequence::intVector(1,10);  
  my $sample = libsequence::init_sample($intv, 1500);
  
=head2 sub init_marginal(nsam)

Simple function to initialize and return a marginal tree.

Parameters:
nsam 	the total sample size (i.e. summed over all populations) that you want to simulate

  my $marg = libsequence::init_marginal(10);
  
=head2 sub coalesce(time, ttl_nsam, current_nsam, c1, c2, nsites, nlinks, sample, sample_history)

Common ancestor routine for coalescent simulation. Merges chromosome segments and updates marginal trees.

Parameters:
time 	the time at which the coalecent event is occuring
ttl_nsam 	the total sample size being simulated
current_nsam 	the current sample size in the simulation
c1 	the array index of the first chromosome involved in the coalescent event
c2 	the array index of the second chromosome involved in the coalescent event
nsites 	the total mutational length of the region begin simulated. In the language of Hudson (1983), this is the number of infinitely-many-alleles loci in the simulation.
nlinks 	a pointer to the number of "links" currently in the simulation. A link is the region between two sites, such that a chromosome currently with k sites has k-1 links
sample 	a pointer to the vector of chromosomes which makes up the sample
sample_history 	a pointer to the ancestral recombination graph

  #my $te = new libsequence::margVector(1, $marg);
  #my $sample_history = new libsequence::margList(1, $marg);
  #my $nlinks = new libsequence::intPointer();
  #$nlinks->assign(499);
  #is(libsequence::coalesce(0,19,19,1,2,1500,$sample,$sample_history), 1);
  
=head2 sub total_time(beg, nsam)

Returns:The total time on the tree.

Parameters:
beg 	A pointer to the beginning of a marginal tree, i.e. the return value of marginal::begin()
nsam 	the total sample size simulated

  my $beg = $marg->begin_const();
  is(libsequence::total_time($beg,10), 0);
  
=head2 sub pick_branch(beg,nsam,rtime)

pick a random branch of a marginal tree

Parameters:
beg 	A pointer to the beginning of a marginal tree, i.e. the return value of marginal::begin()
nsam 	the total sample size simulated
rtime 	a (preferably random) double between 0 and the total_time on the marginal tree from which beg is the iterator

  is(libsequence::pick_branch($beg,10,0),0);
  
=head2 sub get_all_descendants(beg,nsam,branch)

Parameters:
beg 	A pointer to the beginning of a marginal tree, i.e. the return value of marginal::begin()
nsam 	the total sample size simulated
branch 	the index of the branch of the tree whose descendants you want.

Note:
branch must be <= 2*nsam-2, which is checked by assert

  is(libsequence::get_all_descendants($beg,10,0)->[0], 0);
  
=head2 sub is_descendant(beg,ind,branch)

Ask if a tip of a tree is a descendant of a particular branch.

Note:
This function does not check whether ind or branch go out of bounds, and so
the programmer must ensure that both values are <= 2*nsam-2, where nsam is the total
sample size simulated

  ok(!(libsequence::is_descendant($beg,1,0)));
  
=head2 sub pick2(uni,nsam)

Returns:A pair of integers which contains the indexes of two chromosomes in sample

Parameters:
uni 	a random number function/object capable of returning a double-precision random number between 0 and nsam-1
nsam 	the current sample size in the simulation

  my $T = libsequence::gsl_rng_env_setup();
  my $r = libsequence::gsl_rng_alloc($T);
  libsequence::gsl_rng_set($r,0);
  my $uni = new libsequence::gsl_uniform($r);
  is(libsequence::pick2($uni,10)->swig_first_get, 1);
  is(libsequence::pick2($uni,10)->swig_second_get, 9);
  
=head2 sub pick_in_deme(uni, sample, current_nsam,deme_nsam,deme)

Returns: A pair of integers which contains the indexes of two chromosomes in sample

Parameters:
uni 	A random number generator taking two arguments, a and b, and returning a
random variable distributed uniformly over [a,b)

sample 	The current state of the simulated sample
current_nsam 	The total sample size being simuled (the sum of sample sizes over all demes)
deme_nsam 	The sample size of the deme from which you wish to sample
deme 	The index ( 0 <= deme < # populations ) of the deme from which you wish to sample

  my $sample = libsequence::init_sample(libsequence::intVector->new(1,10),100);
  is(libsequence::pick2_in_deme($uni,$sample,10,2,0)->swig_first_get, 0);
  is(libsequence::pick2_in_deme($uni,$sample,10,2,0)->swig_second_get, 1);
  
=head2 sub exponential_change(uni,uni01,expo,init_sample,init_marginal,G,t_begin,t_end,rho=0, size_at_end = -1)

Returns:The ancestral recombination graph (arg) describing the sample history.

Parameters:
uni 	A binary function object (or equivalent) that returns a random deviate between a and b such that a <= x < b. 
a and b are the arguments to operator() of uni

uni01 	A function object (or equivalent) whose operator() takes no arguments and returns a random deviate 0 <= x < 1.

expo 	A unary function object whose operator() takes the mean of an exponential process as an argument and returns 
a deviate from an exponential distribution with that mean

init_sample 	An initialized vector of chromosomes for a single population. For example, this may be the return value
of init_sample. This object is used to copy-construct a non-const sample for the simulation

init_marginal 	An initialized marginal tree of the appropriate sample size for the simulation. For example, the return
value of init_marginal.

G 	The rate of exponential change in effective size. If G>0, the population grows exponentially (forwards in time). 
If G<0, it shrinks (again, forwards in time).

t_begin 	The time in the past (in units of 4Ne generations) at which population size change begins (i.e., ends, moving
forward in time)

t_end 	The time in the past (in units of 4Ne generations) at which populations size change ends (begins forward in time)

rho 	The population recombination rate 4N0r. The number of "sites" simulated is not neccesary, as it can be obtained
from initialized_sample[0].last()+1.

size_at_end 	At time t_end in the past, the population size is set to size_at_end. If size_at_end = 1, the populatio
n is set to the same size that is was at t=0 (i.e. the beginning of the simulation). If size_at_and < 0, the population
size is not adjusted at t_end. In other words, it is left at whatever it grew or shrank to.                    

Precondition:
t_begin>=0 and t_end>=0 and t_end>=t_begin and rho>=0 and initialized_marginal.nsam == initialized_sample.size()

  my $uni01 = new libsequence::gsl_uniform01($r);
  my $expo = new libsequence::gsl_exponential($r);
  my $hist = libsequence::exponential_change($uni,$uni01,$expo,$sample,$marg,.1,1,3);
  
=head2 sub bottleneck(uni,uni01,expo,init_sample,init_marginal,tr,d,f,rho=0,exponential_recovery=False,recovered_size=1)

Returns:The ancestral recombination graph (arg) describing the sample history.

Note:
Preconditions are checked by the assert macro, and are therefore disabled when compiling with -DNDEBUG. No
checks or warnings are otherwised performed nor given.

bottleneck(uni,uni01,expo,init_sample,init_marginal,tr,d,f,rho=0,exponential_recovery=False,recovered_size=1)

Parameters:
uni 	A binary function object (or equivalent) that returns a random deviate between a and b such that a <= x < b. 
a and b are the arguments to operator() of uni

uni01 	A function object (or equivalent) whose operator() takes no arguments and returns a random deviate 0 <= x < 1.

expo 	A unary function object whose operator() takes the mean of an exponential process as an argument and returns a
deviate from an exponential distribution with that mean

init_sample 	An initialized vector of chromosomes for a single population. For example, this may be the return value
of init_sample. This object is used to copy-construct a non-const sample for the simulation

initialized_marginal 	An initialized marginal tree of the appropriate sample size for the simulation. For example, the
return value of init_marginal.

tr 	The time at which the population recovers from the bottleneck. In units of 4N0 generations, where N0 is the effective
size before the bottleneck.

d 	The duration of the bottleneck, in units of 4N0 generations, where N0 is the effective size before the bottleneck.

f 	Bottleneck severity. Define Nb as the effective size during the bottleneck, and N0 the effective size prior to the
bottleneck. f=Nb/N0.

rho 	The population recombination rate 4N0r. The number of "sites" simulated is not neccesary, as it can be obtained
from initialized_sample[0].last()+1.

exponential_recovery 	If true, the population recovers from the bottleneck according to an exponential growth model.
If false, a stepwise bottleneck is assumed.

recovered_size 	If 1, the population recovers to N0 at time tr. If 0.5, the population recovers to 1/2 the pre-bottleneck
size, etc.

  my $hist1 = libsequence::bottleneck($uni,$uni01,$expo,$sample,$marg,.1,.2,.2,10,1,1);

=head2 sub infinites_sites_sim_data(poiss,uni,nsites,history,theta)

Returns:an object of type SimData that represent the sample. (the gametes are also stored in gametes). The SimData object
can be passed directly into class PolySIM for analysis

Parameters:
poiss 	a Poisson random number generator which takes the mean of the poisson as an argument
uni 	a uniform random number generator that takes two doubles as an argument
nsites 	the length of the region begin simulated
history 	the list of marginal histories for the sample
theta 	the coalescent-scaled mutation rate

  my $pos = new libsequence::gsl_poisson($r);
  
=head2 class SimpleSNP

SNP table data format. 

SimpleSNP(diploid = False, isofemale = False): Default Constructor

  my $snp = new libsequence::SimpleSNP();
  
outgroup(): returns true if there is outgroup information, false (defalut) otherwise
    
  ok(!($snp->outgroup()));
  
set_outgroup(): Set the boolean value of outgroup

  $snp->set_outgroup(1);
  ok($snp->outgroup());
  
  
  
=head2 class SimData

Data from coalescent simulations.

SimData(nsame = 0, nsnps = 0): The constructor needs to know the sample size simulated. This is easily obtainted using Sequence::SimParams.
Parameters:
nsams    sample size
nsnps 

  #my $null_data = new libsequence::SimData();
  
SimData(pos,dat): 
Parameters:
pos     vector of doubles representing segregating positions
dat     vector of strings representing sequence data.

  my $pos = new libsequence::doubleVector(4);
  $pos->set(0,.25);
  $pos->set(1,.32);
  $pos->set(2,.34);
  $pos->set(3,.44);
  my $dat = new libsequence::strVector(2);
  $dat->set(0,'A-TC');
  $dat->set(1,'N0G1');
  my $data = new libsequence::SimData($pos,$dat);
  
SimData(sbegin,send):
  my $sbeg = $data->sbegin();
  my $send = $data->send();
  my $data1 = new libsequence::SimData($sbeg,$send);
  
empty(): Returns true if object contains no data, false otherwise

  my $null_data = new libsequence::SimData();
  ok($null_data->empty());
  
GetData(): Returns PolyTable::data, a vector of std::strings containing polymorphic sites. Assuming the vector is returned
to a vector<string> called data, accessing data[i][j] accesses the j-th site of the i-th sequence

  is($data->GetData()->[0],'A-TC');
 
GetPositions(): Returns PolyTable::positions

  is($data->GetPositions()->[1], 0.32);
  
segsites(): Returns the number of segregating sites in the data block

  is($data->segsites(),4);
  
size(): Return how many std::strings are stored in PolyTable::data.

  is($data->size(),2);
  
numsites(): Returns number of sites

  is($data->numsites(),4);
  
positions(): Return the i-th position from the PolyTable::positions.

  is($data->position(2), 0.34);
  
assign(): Returns true if the assignment was successful, false otherwise. The only case where false is returned is if
the number of individuals at each site is not the constan from beg to end.

  my $data2 = new libsequence::SimData();
  my $sbeg = $data->sbegin();
  my $send = $data->send();
  ok($data2->assign($sbeg,$send));
  
RemoveMissing(): go through the data and remove all the sites with missing data (the character N).

  my $data1 = $data;
  $data1->RemoveMissing();
  is($data1->GetData()->[1],'0G1');
  
  
RemoveAmbiguous(): go through the data and remove all the sites with states other than {A,G,C,T,N,0,1,-}

  $dat->set(1,'NEG1');
  my $data2 = new libsequence::SimData($pos,$dat);
  $data2->RemoveAmbiguous();
  is($data2->GetData()->[1],'NG1');

RemoveMultiHits(): go through the data and remove all the sites with more than 2 states segregating. By default, this
routine also removes sites where there are 2 states segregating in the ingroup and the outgroup (if present) has a 3rd state.
        
Parameters:
skipOutgroup 	default is false. If true, the character state of the outgroup is ignored.
outgroup 	the index of the outgroup in the data vector

  my $dat1 = new libsequence::strVector(3);
  $dat1->set(0,'A-TC');
  $dat1->set(1,'N0G1');
  $dat1->set(2,'T-CC');
  $data1 = new libsequence::SimData($pos,$dat1);
  $data1->RemoveMultiHits();
  is($data1->GetData()->[0],'A-C');
  is($data1->GetData()->[1],'N01');
  is($data1->GetData()->[2],'T-C');
  
ApplyFreqFilter(mincount, haveOutgroup = False, outgroup = 0): go through the data and remove all positions where there is a 
variant at count (# of occurences in the sample) < minfreq

Parameters:
mincount 	minimum count of a variant in the data. Variants that occur < mincount times are thrown out.
haveOutgroup 	true if an outgroup is present in the data, false otherwise
outgroup 	the index in the data array containing the outgroup (if present)

  $data2->ApplyFreqFilter(2);
  is($data2->GetData()->[0], '');
  
Binary(haveOutgroup = false, outgroup = 0, strictInfSites = true): Recode the polymorphism table in 0,1 (binary notation)
Parameters:
haveOutgroup 	use true if an outgroup is present, false otherwise
outgroup 	the index of the outgroup in the data vector used to construct the object
strictInfSites 	if true, throw out all sites with > 2 character states (including outgroup!)

Note:
if haveOutgroup== true, then 0 means an ancestral state and 1 a derived state in the resulting. note If haveOutgroup == true,
and there are sites with missing data in the outrgroup sequence,those sites are removed from the data, since its assumed you 
actually want to know ancestral/derived for every site

  $data1->Binary();
  
operator==: Returns true if two SimData object are the same, otherwise false

  ok(!($data == $data1));
  
operator!=: Returns False if two SimData object are the same, otherwise True

  ok($data1 != $data2);
  
operator[]: Return the i-th element of PolyTable::data.

  is($data->__getitem__(0), '-TC');
  
~SimData(): Destructor

  $data->DESTROY();
  
=head2 class PolySites

Polymorphism tables for sequence data.

PolySites(alignment, strictInfsites = 0, ignoregaps = 1, skipMissing = False, skipAdjSNP = False,freqfilter = 0): Constructor. 
This is the constructor if you are using "string-like" data, such as std::string, or Sequence::Fasta. Note that the vector name
is aligment, and that means that every sequence had better be the same length! 

By default, there is no limit to how many characters can "segregate" at a variable position, although if there are more than 4,
most biologists will start to worry. There are, however, times when you may wish to onlu consider sites that have a total of 2 
character states.
(NOTE: by two states, I mean including BOTH the ingroup and the outgroup sequence.) Setting
strictInfSites to 1 will result in making a polymorphic sites object containing only sites with 2 states.

      
Parameters:
alignment 	vector of data
strictInfSites 	if true, throw out all sites with > 2 states
ignoregaps 	if true, do not count gapped sites as polymorphisms
skipMissing 	if true, ignore ALL sites with missing data ('N')
skipAdjSNP 	if does nothing. a placeholder for a future feature
freqfilter 	Defaults to 0. For a polymorphic site to be included in the final table,
the minor allele count in the data (i.e. the number of times the minor allele occurs at that site)
must be strictly greater than freqfilter

Note:
segsite positions are stored as positions (starting from 1)

Warning:
when ignoregaps=false, this class does not do the right thing

  my $v = new libsequence::fastaVector(2);
  $v->set(0,libsequence::Fasta->new('s1','ANTGC-C'));
  $v->set(1,libsequence::Fasta->new('s2','-GGTCCA'));
  my $p = new libsequence::PolySites($v);
  
PolySites(List,stringList): Use this constructor if you already have a list of positions and characters

Parameters:
List 	a list of doubles representing positions of polymorphic positions
stringList 	a vector of strings representing the polymorphic characters
  
  my $l = new libsequence::doubleVector(2);
  $l->set(0,0);
  $l->set(0,4);
  my $strl = new libsequence::strVector(2);
  $strl->set(0,'ATG-');
  $strl->set(1,'CCCT');
  my $p1 = new libsequence::PolySites($l,$strl);
  
PolySites(sbegin,send): 

  my $sbeg = $p->sbegin();
  my $send = $p->send();
  my $p2 = new libsequence::PolySites($sbeg,$send);
  
empty(): Returns true if object contains no data, false otherwise

  ok(!($p->empty()));
  
GetData(): Returns PolyTable::data, a vector of std::strings containing polymorphic sites. Assuming the vector is returned
to a vector<string> called data, accessing data[i][j] accesses the j-th site of the i-th sequence

  is($p->GetData()->[0],'TGC');
  is($p->GetData()->[1], 'GTA');

GetPositions(): Returns PolyTable::positions

  is($p->GetPositions()->[0], 3.0);
  is($p->GetPositions()->[1], 4.0);
  is($p->GetPositions()->[2], 7.0);

  
size(): Return how many std::strings are stored in PolyTable::data.

  is($p->size(),2);
  
numsites(): Returns number of sites

  is($p->numsites(),3);
  
positions(): Return the i-th position from the PolyTable::positions.

  is($p->position(2), 7.0);
  
assign(): Returns true if the assignment was successful, false otherwise. The only case where false is returned is if
the number of individuals at each site is not the constan from beg to end.

  my $p3 = new libsequence::PolySites();
  ok($p3->assign($p2->sbegin(),$p2->send()));
  
ApplyFreqFilter(mincount, haveOutgroup = False, outgroup = 0): go through the data and remove all positions where there is a 
variant at count (# of occurences in the sample) < minfreq

Parameters:
mincount 	minimum count of a variant in the data. Variants that occur < mincount times are thrown out.
haveOutgroup 	true if an outgroup is present in the data, false otherwise
outgroup 	the index in the data array containing the outgroup (if present)

  $p2->ApplyFreqFilter(2);
  is($p2->GetData()->[0], '');
  
Binary(haveOutgroup = false, outgroup = 0, strictInfSites = true): Recode the polymorphism table in 0,1 (binary notation)
Parameters:
haveOutgroup 	use true if an outgroup is present, false otherwise
outgroup 	the index of the outgroup in the data vector used to construct the object
strictInfSites 	if true, throw out all sites with > 2 character states (including outgroup!)

Note:
if haveOutgroup== true, then 0 means an ancestral state and 1 a derived state in the resulting. note If haveOutgroup == true,
and there are sites with missing data in the outrgroup sequence,those sites are removed from the data, since its assumed you 
actually want to know ancestral/derived for every site

  $p->Binary();
  is($p->GetData()->[0],'000');
  is($p->GetData()->[1],'111');
  
operator==: Returns true if two SimData object are the same, otherwise false

  ok(!($p == $p1));
  
operator!=: Returns False if two SimData object are the same, otherwise True

  ok($p1 != $p2);
  
operator[]: Return the i-th element of PolyTable::data.

  is($p->__getitem__(0),'000');

  
~PolySites():

  $p->DESTROY();
  
=head2 sub rotatePolyTable(data)

Rotate a polymorphism table into a vector of pairs, where the pairs are of type std::pair<double, string>, representing the 
site position and the characters at that site

Parameters:
data 	a pointer to a Sequence::PolyTable

  my $v = new libsequence::fastaVector(2);
  $v->set(0,libsequence::Fasta->new('s1','ATGCG'));
  $v->set(1,libsequence::Fasta->new('s2','CG-TT'));
  my $p = new libsequence::PolySites($v);
  is(libsequence::rotatePolyTable($p)->[0]->swig_first_get, 1);
  is(libsequence::rotatePolyTable($p)->[0]->swig_second_get, 'AC');
  
=head2 class PolySNP

Molecular population genetic analysis

PolySNP(fastaVectorObj):
Parameters:
data 	a valid object of type Sequence::PolyTable
haveOutgroup 	true if an outgroup is present, false otherwise
outgroup 	if haveOutgroup is true, outgroup is the index of that sequence in data
totMuts 	if true (the default) use the total number of inferred mutations,otherwise use the total number of polymorphic sites in calculations

  my $v = new libsequence::fastaVector(3);
  $v->set(0, libsequence::Fasta->new('s1', 'ATGCNC'));
  $v->set(1, libsequence::Fasta->new('s2', 'GCCA-T'));
  $v->set(2, libsequence::Fasta->new('s3', '0GA1TC'));
  my $p = new libsequence::PolySites($v);
  my $snp = new libsequence::PolySNP($p);
  
ThetaPi(): Calculated here as the sum of 1.0 - sum of site homozygosity accross sites.

  is($snp->ThetaPi(), 4.666666666666667);
  
ThetaW(): The classic "Watterson's Theta" statistic, generalized to missing data and multiple mutations per site:

  is($snp->ThetaW(), 6.0);
  
ThetaH(): Calculate Theta ( = 4Nu) from site homozygosity, a la Fay and Wu (2000). This statistic is problematic in general to 
calculate when there are multiple hits. The test requires that the ancestral state (inferred from the outgroup) still be segregating
in the ingroup. If that is not true, the site is skipped.

  my $snp1 = new libsequence::PolySNP($p,1,1,1);
  is($snp1->ThetaH(), 0);
  
ThetaL(): Calculate Theta ( = 4Nu) from site homozygosity, corresponding to equation 1 in Thornton and Andolfatto (Genetics) 
"Approximate Bayesian Inference reveals evidence for a recent, severe, bottleneck in a Netherlands population of Drosophila melanogaster," 
(although we labelled in  in that paper) The test requires that the ancestral state (inferred from the outgroup) still be segregating in
the ingroup. If that is not true, the site is skipped.

  is($snp1->ThetaL(), 0);
  
VarPi():Total variance of mean pairwise differences. Tajima in Takahata/Clark book, (13).

  is($snp->VarPi(), 9.7777777777777803);
  
StochasticVarPi(): Stochastic variance of mean pairwise differences. Tajima in Takahata/Clark book, (14).

  is($snp->StochasticVarPi(), 4.2222222222222232);
  
SamplingVarPi(): Component of variance of mean pairwise differences from sampling. Tajima in Takahata/Clark book, (15)

  is($snp->SamplingVarPi(), 5.5555555555555562);
  
NumPoly(): Returns the number of polymorphic (segregating) sites in data

  is($snp->NumPoly(), 5);
  
VarThetaW(): Returns:Variance of Watterson's Theta (ThetaW()).

  is($snp->VarThetaW(), 15.428571428571429);
  
NumMutations(): Returns:the total number of mutations in the data. The number of mutations per site = number of states per site - 1
  
  is($snp->NumMutations(), 9);
  
NumSingletons(): Returns:number of polymorphisms that appear once in the data, without respect to ancestral/derived

  is($snp->NumSingletons(), 13);

NumExternalMutations(): Returns:the number of derived singletons.

  is($snp->NumExternalMutations(), 4294967295);
  
TajimasD(): A common summary of the site frequency spectrum.  This routine does calculate the denominator of the test statistic.
  
  print $snp1->TajimasD();
  
Hprime(): ReturnsThetaPi-ThetaH/(~Var(ThetaPi-ThetaH)). This corresponds to Equation 5 in Thornton and Andolfatto 
(Genetics) "Approximate Bayesian Inference reveals evidence for a recent, severe, bottleneck in a Netherlands population
of Drosophila melanogaster"

  print $snp1->Hprime();

FuLiD(): Returns The Fu and Li (1993) D statistic, or nan if there are no polymorphic sites.  

  print $snp1->FuLiD();
  
FuLiF(): Returns The Fu and Li (1993) F statistic, or nan if there are no polymorphic sites.  

  print $snp1->FuLiF();
  
FuLiDStar(): Returns The Fu and Li (1993) D * statistic, or nan if there are no polymorphic sites. 

  print $snp1->FuLiDStar();
  
FuLiFStar(): Returns The Fu and Li (1993) F * statistic, or nan if there are no polymorphic sites. 

  print $snp1->FuLiFStar();
  
Dnominator(): Returns Denominator of Tajima's D, or nan if there are no polymorphic sites

  is($snp->Dnominator(), 0);
  
DandVH():  Returns the haplotype diversity of the data.

  is($snp1->DandVH(), 1.0);
  
DandVK(): Returns number of haplotypes in the sample

  is($snp1->DandVK(), 2);
  
WallsB(): Returns Wall's B Statistic.

  is($snp1->WallsB(), 1.0);
  
WallsBprime(): Returns Wall's B Statistic.

  is($snp1->WallsBprime(), 3);
  
WallsQ(): Returns Wall's Q Statistic.

  is($snp1->WallsQ(), 1.0);
  
HudsonsC(): Returns Returns:Hudson's (1987) estimator of , an estimator of the population recombination rate that depends on the 
variance of the site frequencies. The calculation is made by a call to Recombination::HudsonsC

  is($snp1->HudsonsC(), 10000.0);

Minrec(): Returns:The minimum number of recombination events observed in the sample (Hudson and Kaplan 1985). Will return SEQMAXUNSIGNED
if there are < 2 segregating sites.

  is($snp1->Minrec(), 0);
  
~PolySNP(): Destructor

  $snp->DESTROY();
  
=head2 class PolySIM

Analysis of coalescent simulation data.

PolySIM(data): Constructor. data is a valid object of type Sequence::Simdata

  my $pos = new libsequence::doubleVector(4);
  $pos->set(0, .25);
  $pos->set(1, .32);
  $pos->set(2, .34);
  $pos->set(3, .44);
  my $dat = new libsequence::strVector(2);
  $dat->set(0, 'A-TC');
  $dat->set(1, 'NAGG');
  my $d = new libsequence::SimData($pos,$dat);
  my $sim = new libsequence::PolySIM($d);
  
ThetaPi(): Calculated here as the sum of 1.0 - sum of site homozygosity accross sites.

  is($sim->ThetaPi(), 0);
  
ThetaW(): The classic "Watterson's Theta" statistic, generalized to missing data and multiple mutations per site:

  is($sim->ThetaW(), 2.0);
    
ThetaH(): Calculate Theta ( = 4Nu) from site homozygosity, a la Fay and Wu (2000). This statistic is problematic in general to 
calculate when there are multiple hits. The test requires that the ancestral state (inferred from the outgroup) still be segregating
in the ingroup. If that is not true, the site is skipped.

  is($sim->ThetaH(), 0);
  
ThetaL(): Calculate Theta ( = 4Nu) from site homozygosity, corresponding to equation 1 in Thornton and Andolfatto (Genetics) 
"Approximate Bayesian Inference reveals evidence for a recent, severe, bottleneck in a Netherlands population of Drosophila melanogaster," 
(although we labelled in  in that paper) The test requires that the ancestral state (inferred from the outgroup) still be segregating in
the ingroup. If that is not true, the site is skipped.

  is($sim->ThetaL(), 0);
  
VarPi():Total variance of mean pairwise differences. Tajima in Takahata/Clark book, (13).

  is($sim->VarPi(), 0);
  
StochasticVarPi(): Stochastic variance of mean pairwise differences. Tajima in Takahata/Clark book, (14).

  is($sim->StochasticVarPi(), 0);
  
SamplingVarPi(): Component of variance of mean pairwise differences from sampling. Tajima in Takahata/Clark book, (15)

  is($sim->SamplingVarPi(), 0);
  
NumPoly(): Returns the number of polymorphic (segregating) sites in data

  is($sim->NumPoly(), 2);
  
VarThetaW(): Returns:Variance of Watterson's Theta (ThetaW()).

  is($sim->VarThetaW(), 3.0);
  
NumMutations(): Returns:the total number of mutations in the data. The number of mutations per site = number of states per site - 1
  
  is($sim->NumMutations(), 2);
  
NumSingletons(): Returns:number of polymorphisms that appear once in the data, without respect to ancestral/derived

  is($sim->NumSingletons(), 0);

NumExternalMutations(): Returns:the number of derived singletons.

  is($sim->NumExternalMutations(), 0);
  
TajimasD(): A common summary of the site frequency spectrum.  This routine does calculate the denominator of the test statistic.
  
  print $sim->TajimasD();
  
Hprime(): ReturnsThetaPi-ThetaH/(~Var(ThetaPi-ThetaH)). This corresponds to Equation 5 in Thornton and Andolfatto 
(Genetics) "Approximate Bayesian Inference reveals evidence for a recent, severe, bottleneck in a Netherlands population
of Drosophila melanogaster"

  print $sim->Hprime();

FuLiD(): Returns The Fu and Li (1993) D statistic, or nan if there are no polymorphic sites.  

  print $sim->FuLiD();
  
FuLiF(): Returns The Fu and Li (1993) F statistic, or nan if there are no polymorphic sites.  

  print $sim->FuLiF();
  
FuLiDStar(): Returns The Fu and Li (1993) D * statistic, or nan if there are no polymorphic sites. 

  print $sim->FuLiDStar();
  
FuLiFStar(): Returns The Fu and Li (1993) F * statistic, or nan if there are no polymorphic sites. 

  print $sim->FuLiFStar();
  
Dnominator(): Returns Denominator of Tajima's D, or nan if there are no polymorphic sites

  is($sim->Dnominator(), 0);
  
DandVH():  Returns the haplotype diversity of the data.

  is($sim->DandVH(), 1.0);
  
DandVK(): Returns number of haplotypes in the sample

  is($sim->DandVK(), 2);
  
WallsB(): Returns Wall's B Statistic.

  is($sim->WallsB(), 0.0);
  
WallsBprime(): Returns Wall's B Statistic.

  is($sim->WallsBprime(), 0);
  
WallsQ(): Returns Wall's Q Statistic.

  is($sim->WallsQ(), 0.0);
  
HudsonsC(): Returns Returns:Hudson's (1987) estimator of , an estimator of the population recombination rate that depends on the 
variance of the site frequencies. The calculation is made by a call to Recombination::HudsonsC

  is($sim->HudsonsC(), 1.5646219209131118e-07);

Minrec(): Returns:The minimum number of recombination events observed in the sample (Hudson and Kaplan 1985). Will return SEQMAXUNSIGNED
if there are < 2 segregating sites.

  is($sim->Minrec(), 0);
  
HudsonsHaplogypeTest(subsize,subss): returns a 1 if the number of polymorphisms in a randomly generated subsample of the
data is less than or equal to subss, 0 otherwise.

Parameters:
subsize 	the size of the subsample
subss 	the number of segregating sites in the subsample

  is($sim->HudsonsHaplotypeTest(2,4), 1);

Disequilibrium(): Returns:A vector of statistics related to LD and distance in the sample. An empty vector is returned
if there are < 2 polymorphic sites in the sample. See the documentation for Recombination::Disequilibrium for a description 
of the return vector.

  is($sim->Disequilibrium()->[0]->get(0), 0.34);
  is($sim->Disequilibrium()->[0]->get(1), 0.44);
  is($sim->Disequilibrium()->[0]->get(2), 1);
  is($sim->Disequilibrium()->[0]->get(3), 0.25);
  is($sim->Disequilibrium()->[0]->get(4), 1);

  
~PolySNP(): Destructor

  $snp->DESTROY();
    
=head2 sub HudsonC(data, haveOutgroup, outgroup)  

Returns Hudson's (1987) Genetical Research 50:245-250 moment estimator of the population recombination rate. 

  my $v = new libsequence::fastaVector(2);
  $v->set(0, libsequence::Fasta->new('s1','ATCC'));
  $v->set(1, libsequence::Fasta->new('s2','TGGG'));
  my $p = new libsequence::PolySites($v);
  is(libsequence::HudsonsC($p,0,0), 10000.0);
  
=head2 sub Disquilibrium(data, haveOutgroup, outgroup,mincount) 

calculated several measures of LD for all pairs of sites, and implements a frequency filter to remove low-frequency variants if desired.
  
  is(libsequence::Disequilibrium($p,0,0,1)->[0]->get(0), 1.0);
  is(libsequence::Disequilibrium($p,0,0,1)->[1]->get(1), 3.0);
  is(libsequence::Disequilibrium($p,0,0,1)->[2]->get(2), 1.0);
  is(libsequence::Disequilibrium($p,0,0,1)->[3]->get(3), .25);
  is(libsequence::Disequilibrium($p,0,0,1)->[4]->get(4), 1.0);

=head2 class PolyTableSlice_SimData

calculates sliding windows of a fixed number of segregating sites. This template is instantiated by Sequence::SimData type

PolyTableSlice_SimData(beg,end,window_size_S,step_len)
Parameters:
beg 	A pointer the first segregating site in the data
end 	A pointer to one-past-the-last segregating site in the data
window_size_S 	The number of segregating sites in each window
step_len 	The number of segregating sites by which to "jump" for each new window

  my $pos = new libsequence::doubleVector(4);
  $pos->set(0,.25);
  $pos->set(1,.32);
  $pos->set(2,.34);
  $pos->set(3,.44);
  my $dat = new libsequence::strVector(2);
  $dat->set(0,'A-TC');
  $dat->set(1,'NAGG');
  my $d = new libsequence::SimData($pos,$dat);
  my $dslic = new libsequence::PolyTableSlice_SimData($d->sbegin(),$d->send(),100,1000);
  
PolyTableSlice_SimData(beg,end,window_size,step_len,alignment_length,physical_scale)
Parameters:
beg 	A pointer the first segregating site in the data
end 	A pointer to one-past-the-last segregating site in the data
window_size 	The size of the sliding window
step_len 	The distance by which the window jumps
alignment_length 	The length of the alignment in base pairs.
physical_scale. For SNP data, set this to 1. For data with positions labelled on the interval
[0,1), set this equal to alignment_length. For example, if you simulate data for a 1000bp region
using Hudson's program "ms", set this to 1000.

  my $dslic = new libsequence::PolyTableSlice_SimData($d->sbegin(),$d->send(),100,100,1000,1000);
  
get_slice(beg):Returns The window pointed to by the iterator itr. 
Exceptions: Sequence::SeqException 	if iterator is out of range ( >= this->end() )

  my $dd = $dslic->get_slice($dslic->begin());
  is($dd->GetData()->[0], undef);


operator[]: Returns the i-th window Exceptions: Sequence::SeqException 	if subscript i is out of range

  my $d1 = $dslic->__getitem__(2);
  is($d1->GetData()->[0],'A');
  is($d1->GetData()->[1],'N');
  
size(): Returns The number of windows stored

  is($dslic->size(),10);
  
  
=head2 class PolyTableSlice_PolySites

calculates sliding windows of a fixed number of segregating sites. This template is instantiated by Sequence::SimData type

PolyTableSlice_PolySites(beg,end,window_size_S,step_len)
Parameters:
beg 	A pointer the first segregating site in the data
end 	A pointer to one-past-the-last segregating site in the data
window_size_S 	The number of segregating sites in each window
step_len 	The number of segregating sites by which to "jump" for each new window

  my $v = new libsequence::fastaVector(2);
  $v->set(0,libsequence::Fasta->new('s1','ANTGC-C'));
  $v->set(1,libsequence::Fasta->new('s2','-GGTCCA'));
  my $p = new libsequence::PolySites($v);
  my $pslic = new libsequence::PolyTableSlice_PolySites($p->sbegin(),$p->send(),100,100);
  
PolyTableSlice_PolySites(beg,end,window_size,step_len,alignment_length,physical_scale)
Parameters:
beg 	A pointer the first segregating site in the data
end 	A pointer to one-past-the-last segregating site in the data
window_size 	The size of the sliding window
step_len 	The distance by which the window jumps
alignment_length 	The length of the alignment in base pairs.
physical_scale. For SNP data, set this to 1. For data with positions labelled on the interval
[0,1), set this equal to alignment_length. For example, if you simulate data for a 1000bp region
using Hudson's program "ms", set this to 1000.

  my $pslic = new libsequence::PolyTableSlice_PolySites($p->sbegin(),$p->send(),100,100,1000);
  
get_slice(beg):Returns The window pointed to by the iterator itr. 
Exceptions: Sequence::SeqException 	if iterator is out of range ( >= this->end() )

  my $pp = $pslic->get_slice($pslic->begin());
  is($pp->GetData()->[0], 'TGC');
  is($pp->GetData()->[1], 'GTA');



operator[]: Returns the i-th window Exceptions: Sequence::SeqException 	if subscript i is out of range

  my $p1 = $pslic->__getitem__(2);
  is($p1->GetData()->[0],undef);
  
size(): Returns The number of windows stored

  is($pslic->size(),10);

=head2 sub Snn_test(snpTable,config,npop,uni_int,nperms)

Conducts a permutation-test of Hudson's Snn (sequence nearest-neighbor) statistic.
Returns:A pair of doubles (std::pair<double,double>). the first member of the pair is the observed value
of the statistic, and the second member is the estimated p-value

Parameters:
snpTable 	The data on which we wish to perform the test.

config 	An array of the sample sizes in each deme.

npop 	The number of populations. For example, npop could equal config.size() if config were a vector

uni_int 	A random number generator whose operator() takes one argument, n, and returns a value 
uniformly-distributed on the half-open interval [0,N)

nperms 	The number of permutations to do for the test

  my $v = new libsequence::fastaVector(2);
  $v->set(0,libsequence::Fasta->new('s1','ANTGC-C'));
  $v->set(1,libsequence::Fasta->new('s2','-GGTCCA'));
  my $p = new libsequence::PolySites($v);
  my $config = new libsequence::unsignedArray(4);
  $config->setitem(0,100);
  $config->setitem(1,105);
  $config->setitem(2,200);
  $config->setitem(3,85);
  my $npop = 4;
  my $T = libsequence::gsl_rng_env_setup();
  my $r = libsequence::gsl_rng_alloc($T);
  libsequence::gsl_rng_set($r,0);
  my $uni_int = new libsequence::gsl_uniform_int($r);
  is(libsequence::Snn_test($p,$config,$npop,$uni_int)->swig_first_get, 1.0);
  is(libsequence::Snn_test($p,$config,$npop,$uni_int)->swig_second_get, 1.0);




=head1 Statics

=head2 sub mean()

Returns: the mean of the range

Parameters:
beg 	an iterator
end 	an iterator

>   my $x = new libsequence::doubleVector(3);
>   $x->set(0,.5);
>   $x->set(1,5.7);
>   $x->set(2,12.6);
>   my $beg = $x->begin();
>   my $end = $x->end();
>   print libsequence::mean($x->begin(),$x->end());

  



  
  
  


  





 
=cut